import type { Marker, StageProps } from '@tableslayer/ui';
import { SocketIOProvider } from 'y-socket.io';
import * as Y from 'yjs';

export interface SceneMetadata {
  id: string;
  name: string;
  order: number;
  mapLocation?: string | null;
  mapThumbLocation?: string | null;
  gameSessionId: string;
  thumb?: {
    resizedUrl: string;
    originalUrl?: string;
  };
}

export interface CursorData {
  userId: string;
  position: { x: number; y: number };
  normalizedPosition: { x: number; y: number };
  lastMoveTime: number;
}

export interface LocalViewportState {
  sceneOffset: { x: number; y: number };
  sceneZoom: number;
}

export interface SceneData {
  stageProps: StageProps;
  markers: Marker[];
  localStates: Record<string, LocalViewportState>;
  lastSavedAt: number;
  saveInProgress: boolean;
  activeSaver?: string;
}

export interface PartyState {
  isPaused: boolean;
  activeSceneId?: string;
  cursors: Record<string, CursorData>;
}

/**
 * Y.js-powered Party Data Manager using Socket.IO provider
 */
export class PartyDataManager {
  private doc: Y.Doc;
  private provider: SocketIOProvider;
  private partyDoc: Y.Doc; // Separate document for party-level state
  private partyProvider: SocketIOProvider; // Separate provider for party-level state
  private userId: string;
  private partyId: string;
  private clientId: number; // Unique ID for this editor instance

  // Game session-specific Y.js shared data structures
  private yScenes: Y.Map<any>;
  private yScenesList: Y.Array<SceneMetadata>;
  private yGameSessionMeta: Y.Map<any>; // For game session metadata like initialization flags
  private yCursors: Y.Map<CursorData>;

  // Party-level Y.js shared data structures
  private yPartyState: Y.Map<any>;

  // Reactive state
  private subscribers = new Set<() => void>();
  private isConnected = false;

  // Track which scenes this specific instance has observers for (local to this editor)
  private sceneObservers = new Set<string>();

  constructor(partyId: string, userId: string, gameSessionId?: string) {
    this.userId = userId;
    this.partyId = partyId;

    const socketUrl = window.location.origin;

    // Initialize game session-specific Y.js document and provider
    this.doc = new Y.Doc();

    // Get unique client ID for this editor instance (auto-generated by Y.js)
    this.clientId = this.doc.clientID;
    const gameSessionRoomName = gameSessionId ? `gameSession-${gameSessionId}` : `party-${partyId}`;

    console.log(
      `PartyDataManager connecting to game session Y.js: ${socketUrl}, room: ${gameSessionRoomName}, clientId: ${this.clientId}, userId: ${this.userId}, gameSessionId: ${gameSessionId}`
    );

    this.provider = new SocketIOProvider(socketUrl, gameSessionRoomName, this.doc, {
      autoConnect: true,
      resyncInterval: -1,
      disableBc: false
    });

    // Initialize party-level Y.js document and provider (shared across all game sessions)
    this.partyDoc = new Y.Doc();
    const partyRoomName = `party-${partyId}`;

    console.log(`PartyDataManager connecting to party-level Y.js: ${socketUrl}, room: ${partyRoomName}`);

    this.partyProvider = new SocketIOProvider(socketUrl, partyRoomName, this.partyDoc, {
      autoConnect: true,
      resyncInterval: -1,
      disableBc: false
    });

    // Initialize game session-specific shared data structures
    this.yScenes = this.doc.getMap('scenes');
    this.yScenesList = this.doc.getArray('scenesList');
    this.yGameSessionMeta = this.doc.getMap('gameSessionMeta');
    this.yCursors = this.doc.getMap('cursors');

    // Initialize party-level shared data structures
    this.yPartyState = this.partyDoc.getMap('partyState');

    // Set up connection status listeners for both providers
    this.provider.on('status', (event: { status: string }) => {
      console.log(
        `[${this.clientId}] Y.js game session connection status: ${event.status} - room: ${gameSessionRoomName}`
      );
      // When game session connects, ensure scene observers are properly set up
      if (event.status === 'connected') {
        console.log(`[${this.clientId}] Game session connected - refreshing scene observers for connected state`);
        setTimeout(() => {
          // Clear existing observers and re-add them for connected state
          this.sceneObservers.clear();
          this.ensureSceneObservers();
        }, 100);
      }
      this.notifySubscribers();
    });

    this.partyProvider.on('status', (event: { status: string }) => {
      this.isConnected = event.status === 'connected'; // Use party connection for overall status
      console.log(`[${this.clientId}] Y.js party connection status: ${event.status} - room: ${partyRoomName}`);
      // When party connects, ensure scene observers are properly set up
      if (event.status === 'connected') {
        console.log(`[${this.clientId}] Party connected - ensuring scene observers are set up`);
        setTimeout(() => this.ensureSceneObservers(), 100);
      }
      this.notifySubscribers();
    });

    // Add Y.js sync debugging for game session
    this.provider.on('sync', (isSynced: boolean) => {
      console.log(`[${this.clientId}] Game session Y.js sync status: ${isSynced} - room: ${gameSessionRoomName}`);
    });

    this.partyProvider.on('sync', (isSynced: boolean) => {
      console.log(`[${this.clientId}] Party Y.js sync status: ${isSynced} - room: ${partyRoomName}`);
    });

    // Debug Y.js document updates at the document level
    this.doc.on('update', (update: Uint8Array, origin: any) => {
      console.log(
        `[${this.clientId}] Game session Y.js document update received - origin: ${origin}, updateSize: ${update.length} bytes`
      );
    });

    this.partyDoc.on('update', (update: Uint8Array, origin: any) => {
      console.log(
        `[${this.clientId}] Party Y.js document update received - origin: ${origin}, updateSize: ${update.length} bytes`
      );
    });

    // Listen for data changes
    this.yScenes.observe(() => {
      console.log(`[${this.clientId}] Scenes Map changed - ensuring all scenes have observers`);
      this.ensureSceneObservers();
      this.notifySubscribers();
    });
    this.yScenesList.observe(() => this.notifySubscribers());
    this.yGameSessionMeta.observe(() => this.notifySubscribers());
    this.yPartyState.observe(() => this.notifySubscribers());
    this.yCursors.observe(() => this.notifySubscribers());

    // Ensure any existing scenes have observers
    this.ensureSceneObservers();

    console.log(`PartyDataManager initialized for party: ${partyId}`);
  }

  /**
   * Subscribe to data changes
   */
  subscribe(callback: () => void): () => void {
    this.subscribers.add(callback);
    return () => this.subscribers.delete(callback);
  }

  private notifySubscribers() {
    console.log(
      `[${this.clientId}] Y.js notifySubscribers called - ${this.subscribers.size} subscribers, connections: game=${this.provider.socket?.connected}, party=${this.partyProvider.socket?.connected}`
    );
    this.subscribers.forEach((callback) => callback());
  }

  /**
   * Ensure all scenes have observers for their data changes
   */
  private ensureSceneObservers() {
    // Track which scenes this instance has observers for
    if (!this.sceneObservers) {
      this.sceneObservers = new Set<string>();
    }

    console.log(
      `[${this.clientId}] Ensuring scene observers - current scenes: ${this.yScenes.size}, existing observers: ${this.sceneObservers.size}`
    );
    console.log(
      `[${this.clientId}] Connection status when ensuring observers: game=${this.provider.socket?.connected}, party=${this.partyProvider.socket?.connected}`
    );

    this.yScenes.forEach((sceneDataMap, sceneId) => {
      // Check if THIS instance already has an observer for this scene
      if (sceneDataMap instanceof Y.Map && !this.sceneObservers.has(sceneId)) {
        console.log(`[${this.clientId}] Adding observer to existing scene: ${sceneId} for user: ${this.userId}`);
        sceneDataMap.observe((events, transaction) => {
          // Debug logging for Y.js observer
          console.log(`[${this.clientId}] Y.js observer fired for scene: ${sceneId}`);
          console.log(
            `[${this.clientId}] Transaction details - origin: ${transaction.origin}, local: ${transaction.local}, clientID: ${this.doc.clientID}`
          );
          console.log(`[${this.clientId}] Events:`, events);

          // Only notify if the change came from a different client (prevents feedback loops)
          const origin = transaction.origin;
          const isFromDifferentClient = !origin || origin !== this.clientId;

          console.log(
            `[${this.clientId}] Scene data changed for scene: ${sceneId} - origin: ${origin}, fromDifferentClient: ${isFromDifferentClient}, connection status: game=${this.provider.socket?.connected}, party=${this.partyProvider.socket?.connected}`
          );

          if (isFromDifferentClient) {
            console.log(`[${this.clientId}] Notifying subscribers due to change from different client`);
            this.notifySubscribers();
          } else {
            console.log(`[${this.clientId}] Ignoring update from same client (preventing feedback loop)`);
          }
        });
        // Mark that THIS instance has added an observer (local tracking only)
        this.sceneObservers.add(sceneId);
        console.log(
          `[${this.clientId}] Observer added for scene: ${sceneId}, total observers: ${this.sceneObservers.size}`
        );
      } else if (this.sceneObservers.has(sceneId)) {
        console.log(`[${this.clientId}] Scene ${sceneId} already has observer - skipping`);
      }
    });
  }

  /**
   * Get connection status
   */
  getConnectionStatus(): boolean {
    return this.isConnected;
  }

  /**
   * Initialize scene data from SSR
   */
  initializeSceneData(sceneId: string, stageProps: StageProps, markers: Marker[]) {
    console.log(`[${this.clientId}] Initializing scene data for scene: ${sceneId}`);
    if (!this.yScenes.has(sceneId)) {
      // Create a Y.Map for scene data to enable save coordination
      const sceneDataMap = new Y.Map();
      sceneDataMap.set('stageProps', stageProps);
      sceneDataMap.set('markers', markers);
      sceneDataMap.set('localStates', {});
      sceneDataMap.set('lastSavedAt', Date.now());
      sceneDataMap.set('saveInProgress', false);

      this.yScenes.set(sceneId, sceneDataMap);
      console.log(`[${this.clientId}] Scene data initialized for scene: ${sceneId}`);
    } else {
      console.log(`[${this.clientId}] Scene data already exists for scene: ${sceneId}`);
    }

    // Always ensure this instance has an observer for the scene
    const sceneDataMap = this.yScenes.get(sceneId);
    if (sceneDataMap instanceof Y.Map && !this.sceneObservers.has(sceneId)) {
      console.log(`[${this.clientId}] Adding observer for scene: ${sceneId} for user: ${this.userId}`);
      sceneDataMap.observe((events, transaction) => {
        // Debug logging for Y.js observer
        console.log(`[${this.clientId}] Y.js observer fired for scene: ${sceneId}`);
        console.log(
          `[${this.clientId}] Transaction details - origin: ${transaction.origin}, local: ${transaction.local}, clientID: ${this.doc.clientID}`
        );
        console.log(`[${this.clientId}] Events:`, events);

        // Only notify if the change came from a different client (prevents feedback loops)
        const origin = transaction.origin;
        const isFromDifferentClient = !origin || origin !== this.clientId;

        console.log(
          `[${this.clientId}] Scene data changed for scene: ${sceneId} - origin: ${origin}, fromDifferentClient: ${isFromDifferentClient}, connection status: game=${this.provider.socket?.connected}, party=${this.partyProvider.socket?.connected}`
        );

        if (isFromDifferentClient) {
          console.log(`[${this.clientId}] Notifying subscribers due to change from different client`);
          this.notifySubscribers();
        } else {
          console.log(`[${this.clientId}] Ignoring update from same client (preventing feedback loop)`);
        }
      });
      // Mark that THIS instance has added an observer (local tracking only)
      this.sceneObservers.add(sceneId);
    }
  }

  /**
   * Initialize scenes list from SSR with proper sync coordination
   */
  initializeScenesList(scenes: SceneMetadata[]) {
    if (scenes.length === 0) return;

    // Wait for Y.js to fully sync before making initialization decisions
    const initializeAfterSync = () => {
      const initFlag = this.yGameSessionMeta.get('scenesInitialized');
      const currentScenes = this.yScenesList.toArray();

      console.log(`Y.js sync complete. Flag: ${initFlag}, Current: ${currentScenes.length}, SSR: ${scenes.length}`);

      // If data is massively accumulated (more than 2x expected), force clear everything
      if (currentScenes.length > scenes.length * 2) {
        console.log(
          `Force clearing accumulated Y.js data. Current: ${currentScenes.length}, Expected: ${scenes.length}`
        );
        this.doc.transact(() => {
          this.yScenesList.delete(0, this.yScenesList.length);
          this.yGameSessionMeta.clear();
        });

        // Reinitialize after clearing
        setTimeout(() => {
          this.doc.transact(() => {
            scenes.forEach((scene) => this.yScenesList.push([scene]));
            this.yGameSessionMeta.set('scenesInitialized', true);
            this.yGameSessionMeta.set('lastInitTimestamp', Date.now());
          });
          console.log('Y.js reinitialized with clean data');
        }, 100);
        return;
      }

      // If already initialized recently (within 5 seconds), skip
      const lastInit = this.yGameSessionMeta.get('lastInitTimestamp');
      if (initFlag && lastInit && Date.now() - lastInit < 5000) {
        console.log('Y.js recently initialized, skipping');
        return;
      }

      // Initialize if not done or data doesn't match
      const hasValidData =
        currentScenes.length === scenes.length && currentScenes.every((scene) => scenes.some((s) => s.id === scene.id));

      if (!initFlag || !hasValidData) {
        console.log(`Initializing Y.js scenes. Current: ${currentScenes.length}, SSR: ${scenes.length}`);
        this.doc.transact(() => {
          this.yScenesList.delete(0, this.yScenesList.length);
          scenes.forEach((scene) => this.yScenesList.push([scene]));
          this.yGameSessionMeta.set('scenesInitialized', true);
          this.yGameSessionMeta.set('lastInitTimestamp', Date.now());
        });
      } else {
        console.log('Y.js scenes already properly initialized');
      }
    };

    // Wait for provider to connect and sync
    if (this.isConnected) {
      // Already connected, wait a moment for any pending sync
      setTimeout(initializeAfterSync, 1000);
    } else {
      // Wait for connection, then sync
      const unsubscribe = this.subscribe(() => {
        if (this.isConnected) {
          unsubscribe();
          setTimeout(initializeAfterSync, 1000);
        }
      });
    }
  }

  /**
   * Initialize party state from SSR
   */
  initializePartyState(state: Partial<PartyState>) {
    this.partyDoc.transact(() => {
      Object.entries(state).forEach(([key, value]) => {
        this.yPartyState.set(key, value);
      });
    });
  }

  /**
   * Update cursor position
   */
  updateCursor(position: { x: number; y: number }, normalizedPosition: { x: number; y: number }) {
    if (this.isConnected) {
      const cursorData: CursorData = {
        userId: this.userId,
        position,
        normalizedPosition,
        lastMoveTime: Date.now()
      };

      // Update Y.js shared cursor state
      this.yCursors.set(this.userId, cursorData);
    }
  }

  /**
   * Get current cursors (excluding self)
   */
  getCursors(): Record<string, CursorData> {
    const cursors: Record<string, CursorData> = {};
    this.yCursors.forEach((cursor, userId) => {
      if (userId !== this.userId) {
        cursors[userId] = cursor;
      }
    });
    return cursors;
  }

  /**
   * Get scenes list
   */
  getScenesList(): SceneMetadata[] {
    return this.yScenesList.toArray();
  }

  /**
   * Get party state
   */
  getPartyState(): PartyState {
    const cursors: Record<string, CursorData> = {};
    this.yCursors.forEach((cursor, userId) => {
      cursors[userId] = cursor;
    });

    return {
      isPaused: this.yPartyState.get('isPaused') || false,
      activeSceneId: this.yPartyState.get('activeSceneId'),
      cursors
    };
  }

  /**
   * Update party state
   */
  updatePartyState(key: keyof PartyState, value: any) {
    this.yPartyState.set(key, value);
    // No need to manually notify - Y.js observers handle this
  }

  /**
   * Get scene data
   */
  getSceneData(sceneId: string): SceneData | null {
    const sceneDataMap = this.yScenes.get(sceneId);
    if (!sceneDataMap) {
      console.log(`getSceneData: No scene data found for scene: ${sceneId}`);
      console.log('Available scenes:', Array.from(this.yScenes.keys()));
      return null;
    }

    // Convert Y.Map back to plain object for compatibility
    return {
      stageProps: sceneDataMap.get('stageProps'),
      markers: sceneDataMap.get('markers'),
      localStates: sceneDataMap.get('localStates') || {},
      lastSavedAt: sceneDataMap.get('lastSavedAt'),
      saveInProgress: sceneDataMap.get('saveInProgress') || false,
      activeSaver: sceneDataMap.get('activeSaver')
    };
  }

  /**
   * Update scene stageProps via Y.js transaction
   */
  updateSceneStageProps(sceneId: string, updatedStageProps: StageProps) {
    console.log(
      `[${this.clientId}] Updating scene stageProps for scene: ${sceneId} - connections: game=${this.provider.socket?.connected}, party=${this.partyProvider.socket?.connected}`
    );
    const sceneDataMap = this.yScenes.get(sceneId);
    if (!sceneDataMap) {
      console.warn(`[${this.clientId}] No scene data found for scene: ${sceneId} - cannot update stageProps`);
      console.warn('Available scenes:', Array.from(this.yScenes.keys()));
      return;
    }

    // Use transaction with origin to identify this client's changes
    this.doc.transact(() => {
      console.log(`[${this.clientId}] Setting stageProps for scene ${sceneId} via Y.js transaction`);
      sceneDataMap.set('stageProps', updatedStageProps);
      sceneDataMap.set('lastSavedAt', Date.now());
    }, this.clientId); // Set origin to this client's ID

    console.log(`[${this.clientId}] Scene stageProps Y.js transaction completed for scene: ${sceneId}`);
  }

  /**
   * Add scene to the list
   */
  addScene(scene: SceneMetadata) {
    console.log('Adding scene to Y.js:', scene.name);
    this.doc.transact(() => {
      this.yScenesList.push([scene]);
      // Update timestamp to prevent initialization conflicts
      this.yGameSessionMeta.set('lastInitTimestamp', Date.now());
    });
  }

  /**
   * Update scene metadata
   */
  updateScene(sceneId: string, updates: Partial<SceneMetadata>) {
    const scenes = this.yScenesList.toArray();
    const sceneIndex = scenes.findIndex((scene) => scene.id === sceneId);

    if (sceneIndex !== -1) {
      console.log('Updating scene in Y.js:', sceneId, updates);
      this.doc.transact(() => {
        const updatedScene = { ...scenes[sceneIndex], ...updates };
        this.yScenesList.delete(sceneIndex, 1);
        this.yScenesList.insert(sceneIndex, [updatedScene]);
        this.yGameSessionMeta.set('lastInitTimestamp', Date.now());
      });
    }
  }

  /**
   * Remove scene from the list
   */
  removeScene(sceneId: string) {
    const scenes = this.yScenesList.toArray();
    const sceneIndex = scenes.findIndex((scene) => scene.id === sceneId);

    if (sceneIndex !== -1) {
      console.log('Removing scene from Y.js:', sceneId);

      // Check if this was the active scene and clear it
      const currentActiveSceneId = this.yPartyState.get('activeSceneId');

      this.doc.transact(() => {
        this.yScenesList.delete(sceneIndex, 1);
        this.yGameSessionMeta.set('lastInitTimestamp', Date.now());

        // If this was the active scene, clear the activeSceneId
        if (currentActiveSceneId === sceneId) {
          console.log('Clearing active scene ID from Y.js as deleted scene was active:', sceneId);
          this.yPartyState.set('activeSceneId', null);
        }
      });
    }
  }

  /**
   * Reorder scenes
   */
  reorderScenes(newScenesOrder: SceneMetadata[]) {
    console.log('Reordering scenes in Y.js:', newScenesOrder.length);

    // Check if the current active scene still exists in the new scenes list
    const currentActiveSceneId = this.yPartyState.get('activeSceneId');
    const activeSceneStillExists =
      currentActiveSceneId && newScenesOrder.some((scene) => scene.id === currentActiveSceneId);

    this.doc.transact(() => {
      // Clear current list and replace with new order
      this.yScenesList.delete(0, this.yScenesList.length);
      newScenesOrder.forEach((scene) => this.yScenesList.push([scene]));
      this.yGameSessionMeta.set('lastInitTimestamp', Date.now());

      // If the active scene no longer exists, clear it
      if (currentActiveSceneId && !activeSceneStillExists) {
        console.log('Clearing active scene ID from Y.js as it no longer exists:', currentActiveSceneId);
        this.yPartyState.set('activeSceneId', null);
      }
    });
  }

  /**
   * Save coordination methods
   */

  /**
   * Try to become the active saver for a scene
   */
  becomeActiveSaver(sceneId: string): boolean {
    const sceneData = this.yScenes.get(sceneId);
    if (!sceneData) {
      console.warn('Cannot become active saver: scene not found:', sceneId);
      return false;
    }

    let success = false;

    // Use a transaction to make the check-and-set atomic
    this.doc.transact(() => {
      // Check if save is already in progress by another editor
      if (sceneData.get('saveInProgress') === true) {
        const currentSaver = sceneData.get('activeSaver');
        if (currentSaver && currentSaver !== this.userId) {
          console.log('Save already in progress by another editor:', currentSaver);
          success = false;
          return;
        }
      }

      // Claim save responsibility atomically
      sceneData.set('saveInProgress', true);
      sceneData.set('activeSaver', this.userId);
      success = true;
    });

    if (success) {
      console.log('Became active saver for scene:', sceneId);
    }

    return success;
  }

  /**
   * Release save responsibility for a scene
   */
  releaseActiveSaver(sceneId: string, success: boolean = true) {
    const sceneData = this.yScenes.get(sceneId);
    if (!sceneData) {
      console.warn('Cannot release active saver: scene not found:', sceneId);
      return;
    }

    this.doc.transact(() => {
      const currentSaver = sceneData.get('activeSaver');
      if (currentSaver === this.userId) {
        sceneData.set('saveInProgress', false);
        sceneData.delete('activeSaver');

        if (success) {
          sceneData.set('lastSavedAt', Date.now());
          console.log('Released active saver (success) for scene:', sceneId);
        } else {
          console.log('Released active saver (failed) for scene:', sceneId);
        }
      } else {
        console.warn('Cannot release: not the active saver for scene:', sceneId, 'Current saver:', currentSaver);
      }
    });
  }

  /**
   * Check if save is currently in progress for a scene
   */
  isSaveInProgress(sceneId: string): boolean {
    const sceneData = this.yScenes.get(sceneId);
    return sceneData?.get('saveInProgress') === true;
  }

  /**
   * Get the current active saver for a scene
   */
  getActiveSaver(sceneId: string): string | undefined {
    const sceneData = this.yScenes.get(sceneId);
    return sceneData?.get('activeSaver');
  }

  /**
   * Force clear all Y.js data (for development/debugging)
   */
  clearAllData() {
    this.doc.transact(() => {
      this.yScenesList.delete(0, this.yScenesList.length);
      this.yScenes.clear();
      this.yGameSessionMeta.clear();
      this.yCursors.clear();
    });
    console.log('Y.js data cleared');
  }

  /**
   * Clean up resources
   */
  destroy() {
    console.log(`[${this.clientId}] Destroying PartyDataManager for user ${this.userId}`);
    if (this.provider) {
      this.provider.destroy();
    }
    if (this.partyProvider) {
      this.partyProvider.destroy();
    }
    if (this.doc) {
      this.doc.destroy();
    }
    if (this.partyDoc) {
      this.partyDoc.destroy();
    }
    this.subscribers.clear();
    this.sceneObservers.clear();
  }
}
