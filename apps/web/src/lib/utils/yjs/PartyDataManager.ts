import type { Marker, StageProps } from '@tableslayer/ui';
import YPartyKitProvider from 'y-partykit/provider';
import * as Y from 'yjs';
import { devLog, devWarn } from '../debug';

export interface SceneMetadata {
  id: string;
  name: string;
  order: number;
  mapLocation?: string | null;
  mapThumbLocation?: string | null;
  gameSessionId: string;
  thumb?: {
    resizedUrl: string;
    originalUrl?: string;
  };
}

export interface CursorData {
  userId: string;
  position: { x: number; y: number };
  normalizedPosition: { x: number; y: number };
  lastMoveTime: number;
}

export interface LocalViewportState {
  sceneOffset: { x: number; y: number };
  sceneZoom: number;
}

export interface SceneData {
  stageProps: StageProps;
  markers: Marker[];
  localStates: Record<string, LocalViewportState>;
  lastUpdated: number;
  saveInProgress: boolean;
  activeSaver?: string;
}

export interface PartyState {
  isPaused: boolean;
  activeSceneId?: string;
  cursors: Record<string, CursorData>;
}

/**
 * Y.js-powered Party Data Manager using PartyKit provider
 */
export class PartyDataManager {
  private doc: Y.Doc;
  private gameSessionProvider: YPartyKitProvider;
  private partyDoc: Y.Doc; // Separate document for party-level state
  private partyProvider: YPartyKitProvider; // Separate provider for party-level state
  private userId: string;
  private partyId: string;
  private clientId: number; // Unique ID for this editor instance
  public gameSessionId?: string;

  // Game session-specific Y.js shared data structures
  private yScenes: Y.Map<any>;
  private yScenesList: Y.Array<SceneMetadata>;
  private yGameSessionMeta: Y.Map<any>; // For game session metadata like initialization flags
  private yCursors: Y.Map<CursorData>;

  // Party-level Y.js shared data structures
  private yPartyState: Y.Map<any>;

  // Reactive state
  private subscribers = new Set<() => void>();
  private isConnected = false;

  // Track which scenes this specific instance has observers for (local to this editor)
  private sceneObservers = new Set<string>();

  // SSR data protection (handled at subscription level in page component)
  private freshPageLoadTime: number;

  constructor(partyId: string, userId: string, gameSessionId?: string) {
    this.userId = userId;
    this.partyId = partyId;
    this.gameSessionId = gameSessionId;
    this.freshPageLoadTime = Date.now(); // Track when this instance was created (page load time)

    // Get PartyKit host from environment
    const host = import.meta.env.DEV
      ? 'localhost:1999'
      : import.meta.env.PUBLIC_PARTYKIT_HOST || 'tableslayer.partykit.dev';

    // Initialize game session-specific Y.js document
    this.doc = new Y.Doc();

    // Get unique client ID for this editor instance (auto-generated by Y.js)
    this.clientId = this.doc.clientID;
    const gameSessionRoomName = gameSessionId ? `${gameSessionId}` : `party-${partyId}`;

    devLog(
      'yjs',
      `PartyDataManager connecting to PartyKit: ${host}, room: ${gameSessionRoomName}, clientId: ${this.clientId}`
    );

    // Create game session provider
    this.gameSessionProvider = new YPartyKitProvider(host, gameSessionRoomName, this.doc, {
      party: 'game_session',
      params: { userId }
    });

    // Initialize party-level Y.js document and provider (shared across all game sessions)
    this.partyDoc = new Y.Doc();
    const partyRoomName = partyId;

    devLog('yjs', `PartyDataManager connecting to party-level PartyKit: ${host}, room: ${partyRoomName}`);

    this.partyProvider = new YPartyKitProvider(host, partyRoomName, this.partyDoc, {
      party: 'party',
      params: { userId }
    });

    // Initialize game session-specific shared data structures
    this.yScenes = this.doc.getMap('scenes');
    this.yScenesList = this.doc.getArray('scenesList');
    this.yGameSessionMeta = this.doc.getMap('gameSessionMeta');
    this.yCursors = this.doc.getMap('cursors');

    // Initialize party-level shared data structures
    this.yPartyState = this.partyDoc.getMap('partyState');

    // Set up connection status listeners for both providers
    this.gameSessionProvider.on('status', (event: { status: string }) => {
      devLog(
        'yjs',
        `[${this.clientId}] Y.js game session connection status: ${event.status} - room: ${gameSessionRoomName}`
      );
      // When game session connects, ensure scene observers are properly set up
      if (event.status === 'connected') {
        devLog('yjs', `[${this.clientId}] Game session connected - refreshing scene observers for connected state`);
        setTimeout(() => {
          // Clear existing observers and re-add them for connected state
          this.sceneObservers.clear();
          this.ensureSceneObservers();
          // Trigger a data refresh to sync any missed updates
          this.notifySubscribers();
        }, 100);
      }
      this.notifySubscribers();
    });

    this.partyProvider.on('status', (event: { status: string }) => {
      this.isConnected = event.status === 'connected'; // Use party connection for overall status
      devLog('yjs', `[${this.clientId}] Y.js party connection status: ${event.status} - room: ${partyRoomName}`);
      this.notifySubscribers();
    });

    // Subscribe to awareness updates for cursor tracking
    this.gameSessionProvider.awareness.on('change', () => {
      this.notifySubscribers();
    });

    // Set up observers
    this.setupObservers();
  }

  /**
   * Subscribe to party data changes
   */
  subscribe(callback: () => void): () => void {
    this.subscribers.add(callback);
    return () => this.subscribers.delete(callback);
  }

  private notifySubscribers() {
    this.subscribers.forEach((callback) => callback());
  }

  /**
   * Update cursor position using Y.js awareness
   */
  updateCursor(position: { x: number; y: number }, normalizedPosition: { x: number; y: number }) {
    if (this.isConnected && this.gameSessionProvider.awareness) {
      this.gameSessionProvider.awareness.setLocalStateField('cursor', {
        userId: this.userId,
        position,
        normalizedPosition,
        lastMoveTime: Date.now()
      });
    }
  }

  /**
   * Get current cursors (excluding self) from awareness
   */
  getCursors(): Record<string, CursorData> {
    const cursors: Record<string, CursorData> = {};

    if (this.gameSessionProvider.awareness) {
      this.gameSessionProvider.awareness.getStates().forEach((state, clientId) => {
        if (state.cursor && clientId !== this.gameSessionProvider.awareness.clientID) {
          cursors[state.cursor.userId] = state.cursor;
        }
      });
    }

    return cursors;
  }

  /**
   * Set up observers for Y.js data structures
   */
  private setupObservers() {
    // Observe changes to the scenes list
    this.yScenesList.observeDeep(() => {
      devLog('yjs', `[${this.clientId}] Scenes list changed`);
      this.notifySubscribers();
    });

    // Observe changes to game session metadata
    this.yGameSessionMeta.observeDeep(() => {
      devLog('yjs', `[${this.clientId}] Game session metadata changed`);
      this.notifySubscribers();
    });

    // Observe changes to party state
    this.yPartyState.observeDeep(() => {
      devLog('yjs', `[${this.clientId}] Party state changed`);
      this.notifySubscribers();
    });

    // Observe scenes map changes to add/remove individual scene observers
    this.yScenes.observe((event) => {
      // Check for added scenes
      event.changes.keys.forEach((change, key) => {
        if (change.action === 'add') {
          this.observeScene(key);
        } else if (change.action === 'delete') {
          this.unobserveScene(key);
        }
      });
      this.notifySubscribers();
    });

    // Set up initial scene observers
    this.ensureSceneObservers();
  }

  /**
   * Ensure all scenes have observers
   */
  private ensureSceneObservers() {
    this.yScenes.forEach((_, sceneId) => {
      this.observeScene(sceneId);
    });
  }

  /**
   * Observe changes to a specific scene
   */
  private observeScene(sceneId: string) {
    if (this.sceneObservers.has(sceneId)) {
      return; // Already observing
    }

    const sceneMap = this.yScenes.get(sceneId);
    if (sceneMap && sceneMap instanceof Y.Map) {
      sceneMap.observeDeep(() => {
        devLog('yjs', `[${this.clientId}] Scene ${sceneId} changed`);
        this.notifySubscribers();
      });
      this.sceneObservers.add(sceneId);
      devLog('yjs', `[${this.clientId}] Added observer for scene ${sceneId}`);
    }
  }

  /**
   * Remove observer for a specific scene
   */
  private unobserveScene(sceneId: string) {
    // Y.js handles observer cleanup automatically when the map is deleted
    this.sceneObservers.delete(sceneId);
    devLog('yjs', `[${this.clientId}] Removed observer for scene ${sceneId}`);
  }

  /**
   * Get connection status
   */
  getConnectionStatus(): {
    gameSession: 'disconnected' | 'connecting' | 'connected';
    party: 'disconnected' | 'connecting' | 'connected';
    overall: boolean;
  } {
    const gameSessionStatus = this.gameSessionProvider.shouldConnect
      ? this.gameSessionProvider.wsconnected
        ? 'connected'
        : 'connecting'
      : 'disconnected';

    const partyStatus = this.partyProvider.shouldConnect
      ? this.partyProvider.wsconnected
        ? 'connected'
        : 'connecting'
      : 'disconnected';

    return {
      gameSession: gameSessionStatus,
      party: partyStatus,
      overall: this.isConnected
    };
  }

  /**
   * Get the list of scenes
   */
  getScenesList(): SceneMetadata[] {
    return this.yScenesList.toArray();
  }

  /**
   * Get party state
   */
  getPartyState(): PartyState {
    const isPaused = this.yPartyState.get('isPaused') ?? false;
    const activeSceneId = this.yPartyState.get('activeSceneId');
    const cursors = this.getCursors();

    return {
      isPaused,
      activeSceneId,
      cursors
    };
  }

  /**
   * Update party state
   */
  updatePartyState(key: keyof PartyState, value: any) {
    if (key === 'cursors') {
      devWarn('yjs', 'Cannot directly update cursors - use updateCursor instead');
      return;
    }

    this.partyDoc.transact(() => {
      this.yPartyState.set(key, value);
    });
  }

  /**
   * Get scene data
   */
  getSceneData(sceneId: string): SceneData | null {
    const sceneMap = this.yScenes.get(sceneId);
    if (!sceneMap) {
      return null;
    }

    return {
      stageProps: sceneMap.get('stageProps') || {},
      markers: sceneMap.get('markers') || [],
      localStates: sceneMap.get('localStates') || {},
      lastUpdated: sceneMap.get('lastUpdated') || Date.now(),
      saveInProgress: sceneMap.get('saveInProgress') || false,
      activeSaver: sceneMap.get('activeSaver')
    };
  }

  /**
   * Update scene stage props
   */
  updateSceneStageProps(sceneId: string, stageProps: StageProps) {
    this.doc.transact(() => {
      let sceneMap = this.yScenes.get(sceneId);
      if (!sceneMap) {
        sceneMap = new Y.Map();
        this.yScenes.set(sceneId, sceneMap);
      }
      sceneMap.set('stageProps', stageProps);
    });
  }

  /**
   * Initialize scene data from SSR
   */
  initializeSceneData(sceneId: string, stageProps: StageProps, markers: Marker[]) {
    this.doc.transact(() => {
      let sceneMap = this.yScenes.get(sceneId);
      if (!sceneMap) {
        sceneMap = new Y.Map();
        this.yScenes.set(sceneId, sceneMap);
      }

      // Only initialize if not already set or if data is stale
      const existingStageProps = sceneMap.get('stageProps');
      const existingMarkers = sceneMap.get('markers');

      if (!existingStageProps && !existingMarkers) {
        sceneMap.set('stageProps', stageProps);
        sceneMap.set('markers', markers);
        sceneMap.set('lastUpdated', Date.now());
        sceneMap.set('localStates', {});
        devLog('yjs', `[${this.clientId}] Initialized scene ${sceneId} from SSR data`);
      } else {
        devLog('yjs', `[${this.clientId}] Scene ${sceneId} already has data, skipping SSR initialization`);
      }
    });
  }

  /**
   * Initialize scenes list from SSR
   */
  initializeScenesList(scenes: SceneMetadata[]) {
    const initializeAfterSync = () => {
      const initFlag = this.yGameSessionMeta.get('scenesInitialized');
      const currentScenes = this.yScenesList.toArray();

      // Aggressive cleanup if data is corrupted (e.g., duplicates)
      if (currentScenes.length > scenes.length * 2) {
        devLog(
          'yjs',
          `Force clearing accumulated Y.js data. Current: ${currentScenes.length}, Expected: ${scenes.length}`
        );
        this.doc.transact(() => {
          this.yScenesList.delete(0, this.yScenesList.length);
          this.yGameSessionMeta.clear();
        });

        // Reinitialize after clearing
        setTimeout(() => {
          this.doc.transact(() => {
            scenes.forEach((scene) => this.yScenesList.push([scene]));
            this.yGameSessionMeta.set('scenesInitialized', true);
            this.yGameSessionMeta.set('lastInitTimestamp', Date.now());
          });
          devLog('yjs', 'Y.js reinitialized with clean data');
        }, 100);
        return;
      }

      // If already initialized recently (within 5 seconds), skip
      const lastInit = this.yGameSessionMeta.get('lastInitTimestamp');
      if (initFlag && lastInit && Date.now() - lastInit < 5000) {
        devLog('yjs', 'Y.js recently initialized, skipping');
        return;
      }

      // Initialize if not done or data doesn't match
      const hasValidData =
        currentScenes.length === scenes.length && currentScenes.every((scene) => scenes.some((s) => s.id === scene.id));

      if (!initFlag || !hasValidData) {
        devLog('yjs', `Initializing Y.js scenes. Current: ${currentScenes.length}, SSR: ${scenes.length}`);
        this.doc.transact(() => {
          this.yScenesList.delete(0, this.yScenesList.length);
          scenes.forEach((scene) => this.yScenesList.push([scene]));
          this.yGameSessionMeta.set('scenesInitialized', true);
          this.yGameSessionMeta.set('lastInitTimestamp', Date.now());
        });
      } else {
        devLog('yjs', 'Y.js scenes already properly initialized');
      }
    };

    // Wait for provider to connect and sync
    if (this.isConnected) {
      // Already connected, wait a moment for any pending sync
      setTimeout(initializeAfterSync, 1000);
    } else {
      // Wait for connection, then sync
      const unsubscribe = this.subscribe(() => {
        if (this.isConnected) {
          unsubscribe();
          setTimeout(initializeAfterSync, 1000);
        }
      });
    }
  }

  /**
   * Initialize party state from SSR
   */
  initializePartyState(state: Partial<PartyState>) {
    this.partyDoc.transact(() => {
      Object.entries(state).forEach(([key, value]) => {
        if (key !== 'cursors') {
          // Don't initialize cursors from SSR
          this.yPartyState.set(key, value);
        }
      });
    });
  }

  // Scene management methods remain the same...
  addScene(scene: SceneMetadata) {
    this.doc.transact(() => {
      this.yScenesList.push([scene]);
    });
  }

  updateScene(sceneId: string, updates: Partial<SceneMetadata>) {
    this.doc.transact(() => {
      const scenes = this.yScenesList.toArray();
      const index = scenes.findIndex((s) => s.id === sceneId);
      if (index !== -1) {
        const updatedScene = { ...scenes[index], ...updates };
        this.yScenesList.delete(index, 1);
        this.yScenesList.insert(index, [updatedScene]);
      }
    });
  }

  removeScene(sceneId: string) {
    this.doc.transact(() => {
      const scenes = this.yScenesList.toArray();
      const index = scenes.findIndex((s) => s.id === sceneId);
      if (index !== -1) {
        this.yScenesList.delete(index, 1);
      }
      // Also remove from scenes map
      this.yScenes.delete(sceneId);
    });
  }

  reorderScenes(newScenesOrder: SceneMetadata[]) {
    this.doc.transact(() => {
      this.yScenesList.delete(0, this.yScenesList.length);
      newScenesOrder.forEach((scene) => this.yScenesList.push([scene]));
    });
  }

  // Save coordination methods
  becomeActiveSaver(sceneId: string): boolean {
    const sceneMap = this.yScenes.get(sceneId);
    if (!sceneMap) return false;

    const currentSaver = sceneMap.get('activeSaver');
    const saveInProgress = sceneMap.get('saveInProgress');

    if (saveInProgress && currentSaver && currentSaver !== this.userId) {
      devLog('yjs', `Cannot become active saver - ${currentSaver} is already saving`);
      return false;
    }

    this.doc.transact(() => {
      sceneMap.set('activeSaver', this.userId);
      sceneMap.set('saveInProgress', true);
    });

    return true;
  }

  releaseActiveSaver(sceneId: string, success: boolean = true) {
    const sceneMap = this.yScenes.get(sceneId);
    if (!sceneMap) return;

    this.doc.transact(() => {
      sceneMap.set('activeSaver', null);
      sceneMap.set('saveInProgress', false);
      if (success) {
        sceneMap.set('lastUpdated', Date.now());
      }
    });
  }

  isSaveInProgress(sceneId: string): boolean {
    const sceneMap = this.yScenes.get(sceneId);
    return sceneMap?.get('saveInProgress') || false;
  }

  getActiveSaver(sceneId: string): string | null {
    const sceneMap = this.yScenes.get(sceneId);
    return sceneMap?.get('activeSaver') || null;
  }

  // Debug utilities
  clearAllData() {
    this.doc.transact(() => {
      this.yScenes.clear();
      this.yScenesList.delete(0, this.yScenesList.length);
      this.yGameSessionMeta.clear();
      this.yCursors.clear();
    });
    this.partyDoc.transact(() => {
      this.yPartyState.clear();
    });
  }

  forceSyncCheck() {
    // Force a sync by making a small change
    this.doc.transact(() => {
      this.yGameSessionMeta.set('lastSyncCheck', Date.now());
    });
  }

  // Drift detection
  getSceneLastUpdated(sceneId: string): number | null {
    const sceneMap = this.yScenes.get(sceneId);
    return sceneMap?.get('lastUpdated') || null;
  }

  checkSceneDrift(sceneId: string, dbTimestamp: number): boolean {
    const yjsTimestamp = this.getSceneLastUpdated(sceneId);
    if (!yjsTimestamp) return false;
    return dbTimestamp > yjsTimestamp;
  }

  async detectDrift(fetchSceneTimestamps: () => Promise<Record<string, number>>): Promise<string[]> {
    const dbTimestamps = await fetchSceneTimestamps();
    const driftedScenes: string[] = [];

    for (const [sceneId, dbTimestamp] of Object.entries(dbTimestamps)) {
      if (this.checkSceneDrift(sceneId, dbTimestamp)) {
        driftedScenes.push(sceneId);
      }
    }

    return driftedScenes;
  }

  /**
   * Update scene last updated timestamp
   */
  updateSceneLastUpdated(sceneId: string, timestamp: number) {
    const sceneMap = this.yScenes.get(sceneId);
    if (sceneMap) {
      this.doc.transact(() => {
        sceneMap.set('lastUpdated', timestamp);
      });
    }
  }

  /**
   * Clean up resources
   */
  destroy() {
    devLog('yjs', `[${this.clientId}] Destroying PartyDataManager`);

    // Clean up providers
    this.gameSessionProvider.destroy();
    this.partyProvider.destroy();

    // Clear subscribers
    this.subscribers.clear();

    // Clear observers
    this.sceneObservers.clear();
  }

  /**
   * Connect to a different game session
   */
  switchGameSession(newGameSessionId: string) {
    devLog('yjs', `Switching from game session ${this.gameSessionId} to ${newGameSessionId}`);

    // Destroy current providers
    this.gameSessionProvider.destroy();

    // Create new game session provider
    this.gameSessionId = newGameSessionId;
    this.doc = new Y.Doc();
    this.clientId = this.doc.clientID;

    const host = import.meta.env.DEV
      ? 'localhost:1999'
      : import.meta.env.PUBLIC_PARTYKIT_HOST || 'tableslayer.partykit.dev';

    this.gameSessionProvider = new YPartyKitProvider(host, newGameSessionId, this.doc, {
      party: 'game_session',
      params: { userId: this.userId }
    });

    // Reinitialize data structures
    this.yScenes = this.doc.getMap('scenes');
    this.yScenesList = this.doc.getArray('scenesList');
    this.yGameSessionMeta = this.doc.getMap('gameSessionMeta');
    this.yCursors = this.doc.getMap('cursors');

    // Re-setup observers
    this.sceneObservers.clear();
    this.setupObservers();
  }
}
