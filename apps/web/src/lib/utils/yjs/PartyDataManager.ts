import { dev } from '$app/environment';
import type { Marker, StageProps } from '@tableslayer/ui';
import { SocketIOProvider } from 'y-socket.io';
import * as Y from 'yjs';

export interface SceneMetadata {
  id: string;
  name: string;
  order: number;
  mapLocation?: string | null;
  mapThumbLocation?: string | null;
  gameSessionId: string;
  thumb?: {
    resizedUrl: string;
    originalUrl?: string;
  };
}

export interface CursorData {
  userId: string;
  position: { x: number; y: number };
  normalizedPosition: { x: number; y: number };
  lastMoveTime: number;
}

export interface LocalViewportState {
  sceneOffset: { x: number; y: number };
  sceneZoom: number;
}

export interface SceneData {
  stageProps: StageProps;
  markers: Marker[];
  localStates: Record<string, LocalViewportState>;
  lastUpdated: number;
  saveInProgress: boolean;
  activeSaver?: string;
}

export interface PartyState {
  isPaused: boolean;
  activeSceneId?: string;
  cursors: Record<string, CursorData>;
}

/**
 * Y.js-powered Party Data Manager using Socket.IO provider
 */
export class PartyDataManager {
  private doc: Y.Doc;
  private provider: SocketIOProvider;
  private partyDoc: Y.Doc; // Separate document for party-level state
  private partyProvider: SocketIOProvider; // Separate provider for party-level state
  private userId: string;
  private partyId: string;
  private clientId: number; // Unique ID for this editor instance
  public gameSessionId?: string;

  // Cursor tracking handlers
  private cursorHandlers = new Map<string, (data: any) => void>();

  // Game session-specific Y.js shared data structures
  private yScenes: Y.Map<any>;
  private yScenesList: Y.Array<SceneMetadata>;
  private yGameSessionMeta: Y.Map<any>; // For game session metadata like initialization flags
  private yCursors: Y.Map<CursorData>;

  // Party-level Y.js shared data structures
  private yPartyState: Y.Map<any>;

  // Reactive state
  private subscribers = new Set<() => void>();
  private isConnected = false;

  // Track which scenes this specific instance has observers for (local to this editor)
  private sceneObservers = new Set<string>();

  // SSR data protection (handled at subscription level in page component)
  private freshPageLoadTime: number;

  constructor(partyId: string, userId: string, gameSessionId?: string) {
    this.userId = userId;
    this.partyId = partyId;
    this.gameSessionId = gameSessionId;
    this.freshPageLoadTime = Date.now(); // Track when this instance was created (page load time)

    const socketUrl = window.location.origin;

    // Initialize game session-specific Y.js document and provider
    this.doc = new Y.Doc();

    // Get unique client ID for this editor instance (auto-generated by Y.js)
    this.clientId = this.doc.clientID;
    const gameSessionRoomName = gameSessionId ? `gameSession-${gameSessionId}` : `party-${partyId}`;

    if (dev) {
      console.log(
        `PartyDataManager connecting to game session Y.js: ${socketUrl}, room: ${gameSessionRoomName}, clientId: ${this.clientId}`
      );
    }

    this.provider = new SocketIOProvider(socketUrl, gameSessionRoomName, this.doc, {
      autoConnect: true,
      resyncInterval: -1,
      disableBc: false
    });

    // Initialize party-level Y.js document and provider (shared across all game sessions)
    this.partyDoc = new Y.Doc();
    const partyRoomName = `party-${partyId}`;

    if (dev) console.log(`PartyDataManager connecting to party-level Y.js: ${socketUrl}, room: ${partyRoomName}`);

    this.partyProvider = new SocketIOProvider(socketUrl, partyRoomName, this.partyDoc, {
      autoConnect: true,
      resyncInterval: -1,
      disableBc: false
    });

    // Initialize game session-specific shared data structures
    this.yScenes = this.doc.getMap('scenes');
    this.yScenesList = this.doc.getArray('scenesList');
    this.yGameSessionMeta = this.doc.getMap('gameSessionMeta');
    this.yCursors = this.doc.getMap('cursors');

    // Initialize party-level shared data structures
    this.yPartyState = this.partyDoc.getMap('partyState');

    // Set up connection status listeners for both providers
    this.provider.on('status', (event: { status: string }) => {
      if (dev)
        console.log(
          `[${this.clientId}] Y.js game session connection status: ${event.status} - room: ${gameSessionRoomName}`
        );
      // When game session connects, ensure scene observers are properly set up
      if (event.status === 'connected') {
        if (dev)
          console.log(`[${this.clientId}] Game session connected - refreshing scene observers for connected state`);
        setTimeout(() => {
          // Clear existing observers and re-add them for connected state
          this.sceneObservers.clear();
          this.ensureSceneObservers();
          // Trigger a data refresh to sync any missed updates
          this.notifySubscribers();
        }, 100);
      }
      this.notifySubscribers();
    });

    this.partyProvider.on('status', (event: { status: string }) => {
      this.isConnected = event.status === 'connected'; // Use party connection for overall status
      if (dev) console.log(`[${this.clientId}] Y.js party connection status: ${event.status} - room: ${partyRoomName}`);
      // When party connects, ensure scene observers are properly set up
      if (event.status === 'connected') {
        if (dev) console.log(`[${this.clientId}] Party connected - ensuring scene observers are set up`);
        setTimeout(() => this.ensureSceneObservers(), 100);
      }
      this.notifySubscribers();
    });

    // Add Y.js sync debugging for game session
    this.provider.on('sync', (isSynced: boolean) => {
      if (dev)
        console.log(`[${this.clientId}] Game session Y.js sync status: ${isSynced} - room: ${gameSessionRoomName}`);
    });

    this.partyProvider.on('sync', (isSynced: boolean) => {
      if (dev) console.log(`[${this.clientId}] Party Y.js sync status: ${isSynced} - room: ${partyRoomName}`);
    });

    // Remove verbose Y.js document update logging

    // Remove verbose party document update logging

    // Listen for data changes
    this.yScenes.observe(() => {
      if (dev) console.log(`[${this.clientId}] Scenes Map changed - ensuring all scenes have observers`);
      this.ensureSceneObservers();
      this.notifySubscribers();
    });
    this.yScenesList.observe(() => this.notifySubscribers());
    this.yGameSessionMeta.observe(() => this.notifySubscribers());
    this.yPartyState.observe(() => this.notifySubscribers());
    this.yCursors.observe(() => this.notifySubscribers());

    // Ensure any existing scenes have observers
    this.ensureSceneObservers();

    if (dev) console.log(`PartyDataManager initialized for party: ${partyId}`);
  }

  /**
   * Subscribe to data changes
   */
  subscribe(callback: () => void): () => void {
    this.subscribers.add(callback);
    return () => this.subscribers.delete(callback);
  }

  private notifySubscribers() {
    this.subscribers.forEach((callback) => callback());
  }

  /**
   * Ensure all scenes have observers for their data changes
   */
  private ensureSceneObservers() {
    // Track which scenes this instance has observers for
    if (!this.sceneObservers) {
      this.sceneObservers = new Set<string>();
    }

    if (dev) {
      console.log(
        `[${this.clientId}] Ensuring scene observers - current scenes: ${this.yScenes.size}, existing observers: ${this.sceneObservers.size}`
      );
      console.log(
        `[${this.clientId}] Connection status when ensuring observers: game=${this.provider.socket?.connected}, party=${this.partyProvider.socket?.connected}`
      );
    }

    this.yScenes.forEach((sceneDataMap, sceneId) => {
      // Check if THIS instance already has an observer for this scene
      if (sceneDataMap instanceof Y.Map && !this.sceneObservers.has(sceneId)) {
        if (dev)
          console.log(`[${this.clientId}] Adding observer to existing scene: ${sceneId} for user: ${this.userId}`);
        sceneDataMap.observe((events, transaction) => {
          // Only notify if the change came from a different client (prevents feedback loops)
          const origin = transaction.origin;
          const isFromDifferentClient = !origin || origin !== this.clientId;

          if (dev) {
            console.log(`[${this.clientId}] Y.js observer fired for scene: ${sceneId}`);
            console.log(
              `[${this.clientId}] Transaction details - origin: ${transaction.origin}, local: ${transaction.local}, clientID: ${this.doc.clientID}`
            );
            console.log(`[${this.clientId}] Events:`, events);
            console.log(
              `[${this.clientId}] Scene data changed for scene: ${sceneId} - origin: ${origin}, fromDifferentClient: ${isFromDifferentClient}`
            );
          }

          if (isFromDifferentClient) {
            if (dev) console.log(`[${this.clientId}] Notifying subscribers due to change from different client`);
            this.notifySubscribers();
          } else {
            if (dev) console.log(`[${this.clientId}] Ignoring update from same client (preventing feedback loop)`);
          }
        });
        // Mark that THIS instance has added an observer (local tracking only)
        this.sceneObservers.add(sceneId);
        if (dev)
          console.log(
            `[${this.clientId}] Observer added for scene: ${sceneId}, total observers: ${this.sceneObservers.size}`
          );
      } else if (dev && this.sceneObservers.has(sceneId)) {
        console.log(`[${this.clientId}] Scene ${sceneId} already has observer - skipping`);
      }
    });
  }

  /**
   * Get connection status
   */
  getConnectionStatus(): boolean {
    return this.isConnected;
  }

  /**
   * Initialize scene data from SSR
   */
  initializeSceneData(sceneId: string, stageProps: StageProps, markers: Marker[]) {
    if (dev) {
      console.log(`[${this.clientId}] Initializing scene data for scene: ${sceneId}`);
      console.log(
        `[${this.clientId}] SSR markers provided:`,
        markers.length,
        'markers',
        markers.slice(0, 2).map((m) => ({ id: m.id, title: m.title }))
      );
    }

    const currentTime = Date.now();

    if (!this.yScenes.has(sceneId)) {
      // Create a Y.Map for scene data to enable save coordination
      const sceneDataMap = new Y.Map();
      sceneDataMap.set('stageProps', stageProps);
      sceneDataMap.set('markers', markers);
      sceneDataMap.set('localStates', {});
      sceneDataMap.set('lastUpdated', currentTime);
      sceneDataMap.set('saveInProgress', false);

      this.yScenes.set(sceneId, sceneDataMap);
      if (dev) console.log(`[${this.clientId}] Scene data initialized for scene: ${sceneId}`);
    } else {
      // Scene data exists - check if SSR data should take precedence
      const existingSceneData = this.yScenes.get(sceneId);
      if (existingSceneData instanceof Y.Map) {
        const lastUpdated = existingSceneData.get('lastUpdated') || 0;

        // Check if Y.js has newer data than what we're initializing with
        const existingMarkers = existingSceneData.get('markers') || [];
        const hasMoreMarkers = existingMarkers.length > markers.length;
        const timeSinceSave = currentTime - lastUpdated;

        // Only update if SSR has more recent data or more markers
        // This prevents Editor B from overwriting Editor A's markers
        if (timeSinceSave > 10000 || markers.length > existingMarkers.length) {
          if (dev) {
            console.log(`[${this.clientId}] Updating Y.js with SSR data - SSR has newer/more data`);
            console.log(
              `[${this.clientId}] Time since last save: ${timeSinceSave}ms, SSR markers: ${markers.length}, Y.js markers: ${existingMarkers.length}`
            );
          }

          // Update with fresh SSR data
          this.doc.transact(() => {
            existingSceneData.set('stageProps', stageProps);
            existingSceneData.set('markers', markers);
            existingSceneData.set('lastUpdated', currentTime);
          });
        } else if (dev) {
          console.log(`[${this.clientId}] Keeping existing Y.js data - it's newer than SSR`);
          console.log(
            `[${this.clientId}] Time since last save: ${timeSinceSave}ms, SSR markers: ${markers.length}, Y.js markers: ${existingMarkers.length}`
          );
        }
      }
    }

    // Fresh SSR data loaded for this scene
    if (dev) console.log(`[${this.clientId}] Scene ${sceneId} initialized with fresh SSR data`);

    // Always ensure this instance has an observer for the scene
    const sceneDataMap = this.yScenes.get(sceneId);
    if (sceneDataMap instanceof Y.Map && !this.sceneObservers.has(sceneId)) {
      if (dev) console.log(`[${this.clientId}] Adding observer for scene: ${sceneId} for user: ${this.userId}`);
      sceneDataMap.observe((events, transaction) => {
        // Only notify if the change came from a different client (prevents feedback loops)
        const origin = transaction.origin;
        const isFromDifferentClient = !origin || origin !== this.clientId;

        if (dev) {
          console.log(`[${this.clientId}] Y.js observer fired for scene: ${sceneId}`);
          console.log(
            `[${this.clientId}] Transaction details - origin: ${transaction.origin}, local: ${transaction.local}, clientID: ${this.doc.clientID}`
          );
          console.log(`[${this.clientId}] Events:`, events);
          console.log(
            `[${this.clientId}] Scene data changed for scene: ${sceneId} - origin: ${origin}, fromDifferentClient: ${isFromDifferentClient}`
          );
        }

        if (isFromDifferentClient) {
          if (dev) console.log(`[${this.clientId}] Notifying subscribers due to change from different client`);
          this.notifySubscribers();
        } else {
          if (dev) console.log(`[${this.clientId}] Ignoring update from same client (preventing feedback loop)`);
        }
      });
      // Mark that THIS instance has added an observer (local tracking only)
      this.sceneObservers.add(sceneId);
    }
  }

  /**
   * Initialize scenes list from SSR with proper sync coordination
   */
  initializeScenesList(scenes: SceneMetadata[]) {
    if (scenes.length === 0) return;

    // Wait for Y.js to fully sync before making initialization decisions
    const initializeAfterSync = () => {
      const initFlag = this.yGameSessionMeta.get('scenesInitialized');
      const currentScenes = this.yScenesList.toArray();

      if (dev)
        console.log(`Y.js sync complete. Flag: ${initFlag}, Current: ${currentScenes.length}, SSR: ${scenes.length}`);

      // If data is massively accumulated (more than 2x expected), force clear everything
      if (currentScenes.length > scenes.length * 2) {
        if (dev)
          console.log(
            `Force clearing accumulated Y.js data. Current: ${currentScenes.length}, Expected: ${scenes.length}`
          );
        this.doc.transact(() => {
          this.yScenesList.delete(0, this.yScenesList.length);
          this.yGameSessionMeta.clear();
        });

        // Reinitialize after clearing
        setTimeout(() => {
          this.doc.transact(() => {
            scenes.forEach((scene) => this.yScenesList.push([scene]));
            this.yGameSessionMeta.set('scenesInitialized', true);
            this.yGameSessionMeta.set('lastInitTimestamp', Date.now());
          });
          if (dev) console.log('Y.js reinitialized with clean data');
        }, 100);
        return;
      }

      // If already initialized recently (within 5 seconds), skip
      const lastInit = this.yGameSessionMeta.get('lastInitTimestamp');
      if (initFlag && lastInit && Date.now() - lastInit < 5000) {
        if (dev) console.log('Y.js recently initialized, skipping');
        return;
      }

      // Initialize if not done or data doesn't match
      const hasValidData =
        currentScenes.length === scenes.length && currentScenes.every((scene) => scenes.some((s) => s.id === scene.id));

      if (!initFlag || !hasValidData) {
        if (dev) console.log(`Initializing Y.js scenes. Current: ${currentScenes.length}, SSR: ${scenes.length}`);
        this.doc.transact(() => {
          this.yScenesList.delete(0, this.yScenesList.length);
          scenes.forEach((scene) => this.yScenesList.push([scene]));
          this.yGameSessionMeta.set('scenesInitialized', true);
          this.yGameSessionMeta.set('lastInitTimestamp', Date.now());
        });
      } else if (dev) {
        console.log('Y.js scenes already properly initialized');
      }
    };

    // Wait for provider to connect and sync
    if (this.isConnected) {
      // Already connected, wait a moment for any pending sync
      setTimeout(initializeAfterSync, 1000);
    } else {
      // Wait for connection, then sync
      const unsubscribe = this.subscribe(() => {
        if (this.isConnected) {
          unsubscribe();
          setTimeout(initializeAfterSync, 1000);
        }
      });
    }
  }

  /**
   * Initialize party state from SSR
   */
  initializePartyState(state: Partial<PartyState>) {
    this.partyDoc.transact(() => {
      Object.entries(state).forEach(([key, value]) => {
        this.yPartyState.set(key, value);
      });
    });
  }

  /**
   * Update cursor position
   */
  updateCursor(position: { x: number; y: number }, normalizedPosition: { x: number; y: number }) {
    if (this.isConnected) {
      const cursorData: CursorData = {
        userId: this.userId,
        position,
        normalizedPosition,
        lastMoveTime: Date.now()
      };

      // Update Y.js shared cursor state
      this.yCursors.set(this.userId, cursorData);
    }
  }

  /**
   * Get current cursors (excluding self)
   */
  getCursors(): Record<string, CursorData> {
    const cursors: Record<string, CursorData> = {};
    this.yCursors.forEach((cursor, userId) => {
      if (userId !== this.userId) {
        cursors[userId] = cursor;
      }
    });
    return cursors;
  }

  /**
   * Get scenes list
   */
  getScenesList(): SceneMetadata[] {
    return this.yScenesList.toArray();
  }

  /**
   * Get party state
   */
  getPartyState(): PartyState {
    const cursors: Record<string, CursorData> = {};
    this.yCursors.forEach((cursor, userId) => {
      cursors[userId] = cursor;
    });

    return {
      isPaused: this.yPartyState.get('isPaused') || false,
      activeSceneId: this.yPartyState.get('activeSceneId'),
      cursors
    };
  }

  /**
   * Update party state
   */
  updatePartyState(key: keyof PartyState, value: any) {
    this.yPartyState.set(key, value);
    // No need to manually notify - Y.js observers handle this
  }

  /**
   * Get scene data
   */
  getSceneData(sceneId: string): SceneData | null {
    const sceneDataMap = this.yScenes.get(sceneId);
    if (!sceneDataMap) {
      if (dev) {
        console.log(`getSceneData: No scene data found for scene: ${sceneId}`);
        console.log('Available scenes:', Array.from(this.yScenes.keys()));
      }
      return null;
    }

    // Convert Y.Map back to plain object for compatibility
    return {
      stageProps: sceneDataMap.get('stageProps'),
      markers: sceneDataMap.get('markers'),
      localStates: sceneDataMap.get('localStates') || {},
      lastUpdated: sceneDataMap.get('lastUpdated'),
      saveInProgress: sceneDataMap.get('saveInProgress') || false,
      activeSaver: sceneDataMap.get('activeSaver')
    };
  }

  /**
   * Update scene stageProps via Y.js transaction
   */
  updateSceneStageProps(sceneId: string, updatedStageProps: StageProps) {
    if (dev)
      console.log(
        `[${this.clientId}] Updating scene stageProps for scene: ${sceneId} - connections: game=${this.provider.socket?.connected}, party=${this.partyProvider.socket?.connected}`
      );
    const sceneDataMap = this.yScenes.get(sceneId);
    if (!sceneDataMap) {
      console.warn(`[${this.clientId}] No scene data found for scene: ${sceneId} - cannot update stageProps`);
      console.warn('Available scenes:', Array.from(this.yScenes.keys()));
      return;
    }

    // Use transaction with origin to identify this client's changes
    this.doc.transact(() => {
      if (dev) {
        console.log(`[${this.clientId}] Setting stageProps for scene ${sceneId} via Y.js transaction`);
        console.log(
          `[${this.clientId}] Markers being set:`,
          updatedStageProps.marker?.markers?.map((m) => ({ id: m.id, title: m.title })) || []
        );
      }
      sceneDataMap.set('stageProps', updatedStageProps);
      // Also update the separate markers array to keep it in sync
      if (updatedStageProps.marker?.markers) {
        if (dev)
          console.log(
            `[${this.clientId}] Also updating separate markers array with ${updatedStageProps.marker.markers.length} markers:`,
            updatedStageProps.marker.markers.map((m) => ({ id: m.id, title: m.title }))
          );
        sceneDataMap.set('markers', updatedStageProps.marker.markers);
      }
      sceneDataMap.set('lastUpdated', Date.now());
    }, this.clientId); // Set origin to this client's ID

    if (dev) console.log(`[${this.clientId}] Scene stageProps Y.js transaction completed for scene: ${sceneId}`);
  }

  /**
   * Add scene to the list
   */
  addScene(scene: SceneMetadata) {
    if (dev) console.log('Adding scene to Y.js:', scene.name);
    this.doc.transact(() => {
      this.yScenesList.push([scene]);
      // Update timestamp to prevent initialization conflicts
      this.yGameSessionMeta.set('lastInitTimestamp', Date.now());
    });
  }

  /**
   * Update scene metadata
   */
  updateScene(sceneId: string, updates: Partial<SceneMetadata>) {
    const scenes = this.yScenesList.toArray();
    const sceneIndex = scenes.findIndex((scene) => scene.id === sceneId);

    if (sceneIndex !== -1) {
      if (dev) console.log('Updating scene in Y.js:', sceneId, updates);
      this.doc.transact(() => {
        const updatedScene = { ...scenes[sceneIndex], ...updates };
        this.yScenesList.delete(sceneIndex, 1);
        this.yScenesList.insert(sceneIndex, [updatedScene]);
        this.yGameSessionMeta.set('lastInitTimestamp', Date.now());
      });
    }
  }

  /**
   * Remove scene from the list
   */
  removeScene(sceneId: string) {
    const scenes = this.yScenesList.toArray();
    const sceneIndex = scenes.findIndex((scene) => scene.id === sceneId);

    if (sceneIndex !== -1) {
      if (dev) console.log('Removing scene from Y.js:', sceneId);

      // Check if this was the active scene and clear it
      const currentActiveSceneId = this.yPartyState.get('activeSceneId');

      this.doc.transact(() => {
        this.yScenesList.delete(sceneIndex, 1);
        this.yGameSessionMeta.set('lastInitTimestamp', Date.now());

        // If this was the active scene, clear the activeSceneId
        if (currentActiveSceneId === sceneId) {
          if (dev) console.log('Clearing active scene ID from Y.js as deleted scene was active:', sceneId);
          this.yPartyState.set('activeSceneId', null);
        }
      });
    }
  }

  /**
   * Reorder scenes
   */
  reorderScenes(newScenesOrder: SceneMetadata[]) {
    if (dev) console.log('Reordering scenes in Y.js:', newScenesOrder.length);

    // Check if the current active scene still exists in the new scenes list
    const currentActiveSceneId = this.yPartyState.get('activeSceneId');
    const activeSceneStillExists =
      currentActiveSceneId && newScenesOrder.some((scene) => scene.id === currentActiveSceneId);

    this.doc.transact(() => {
      // Clear current list and replace with new order
      this.yScenesList.delete(0, this.yScenesList.length);
      newScenesOrder.forEach((scene) => this.yScenesList.push([scene]));
      this.yGameSessionMeta.set('lastInitTimestamp', Date.now());

      // If the active scene no longer exists, clear it
      if (currentActiveSceneId && !activeSceneStillExists) {
        if (dev) console.log('Clearing active scene ID from Y.js as it no longer exists:', currentActiveSceneId);
        this.yPartyState.set('activeSceneId', null);
      }
    });
  }

  /**
   * Save coordination methods
   */

  /**
   * Try to become the active saver for a scene
   */
  becomeActiveSaver(sceneId: string): boolean {
    const sceneData = this.yScenes.get(sceneId);
    if (!sceneData) {
      console.warn('Cannot become active saver: scene not found:', sceneId);
      return false;
    }

    let success = false;

    // Use a transaction to make the check-and-set atomic
    this.doc.transact(() => {
      // Check if save is already in progress by another editor
      if (sceneData.get('saveInProgress') === true) {
        const currentSaver = sceneData.get('activeSaver');
        if (currentSaver && currentSaver !== this.userId) {
          if (dev) console.log('Save already in progress by another editor:', currentSaver);
          success = false;
          return;
        }
      }

      // Claim save responsibility atomically
      sceneData.set('saveInProgress', true);
      sceneData.set('activeSaver', this.userId);
      success = true;
    });

    if (success && dev) {
      console.log('Became active saver for scene:', sceneId);
    }

    return success;
  }

  /**
   * Release save responsibility for a scene
   */
  releaseActiveSaver(sceneId: string, success: boolean = true) {
    const sceneData = this.yScenes.get(sceneId);
    if (!sceneData) {
      console.warn('Cannot release active saver: scene not found:', sceneId);
      return;
    }

    this.doc.transact(() => {
      const currentSaver = sceneData.get('activeSaver');
      if (currentSaver === this.userId) {
        sceneData.set('saveInProgress', false);
        sceneData.delete('activeSaver');

        if (success) {
          sceneData.set('lastUpdated', Date.now());
          if (dev) console.log('Released active saver (success) for scene:', sceneId);
        } else if (dev) {
          console.log('Released active saver (failed) for scene:', sceneId);
        }
      } else {
        console.warn('Cannot release: not the active saver for scene:', sceneId, 'Current saver:', currentSaver);
      }
    });
  }

  /**
   * Check if save is currently in progress for a scene
   */
  isSaveInProgress(sceneId: string): boolean {
    const sceneData = this.yScenes.get(sceneId);
    return sceneData?.get('saveInProgress') === true;
  }

  /**
   * Get the current active saver for a scene
   */
  getActiveSaver(sceneId: string): string | undefined {
    const sceneData = this.yScenes.get(sceneId);
    return sceneData?.get('activeSaver');
  }

  /**
   * Force clear all Y.js data (for development/debugging)
   */
  clearAllData() {
    this.doc.transact(() => {
      this.yScenesList.delete(0, this.yScenesList.length);
      this.yScenes.clear();
      this.yGameSessionMeta.clear();
      this.yCursors.clear();
    });
    if (dev) console.log('Y.js data cleared');
  }

  /**
   * Force Y.js to sync and notify subscribers
   * Useful for ensuring idle editors catch up with changes
   */
  forceSyncCheck() {
    if (dev) console.log(`[${this.clientId}] Force sync check triggered`);

    // Trigger a notification cycle to refresh UI
    this.notifySubscribers();

    // If providers support explicit sync, we could trigger that
    // For now, the notification refresh should be sufficient
    return true;
  }

  /**
   * Get the lastUpdated timestamp for a scene from Y.js
   */
  getSceneLastUpdated(sceneId: string): number | null {
    const sceneData = this.yScenes.get(sceneId);
    if (!sceneData) {
      return null;
    }
    return sceneData.get('lastUpdated') || null;
  }

  /**
   * Check if a scene has drifted from the database
   */
  checkSceneDrift(sceneId: string, dbTimestamp: number): boolean {
    const yjsTimestamp = this.getSceneLastUpdated(sceneId);
    if (!yjsTimestamp) {
      // If no Y.js timestamp, don't assume drift (could be initialization lag)
      return false;
    }

    // Database is newer than Y.js - drift detected
    return dbTimestamp > yjsTimestamp;
  }

  /**
   * Detect drift for all scenes and return list of drifted scene IDs
   */
  async detectDrift(fetchSceneTimestamps: () => Promise<Record<string, number>>): Promise<string[]> {
    try {
      const dbTimestamps = await fetchSceneTimestamps();
      const driftedScenes: string[] = [];

      // Only check scenes that have DB timestamps (non-NULL lastSavedAt)
      // Scenes without DB timestamps are either new or haven't been saved since migration
      for (const [sceneId, dbTimestamp] of Object.entries(dbTimestamps)) {
        const yjsTimestamp = this.getSceneLastUpdated(sceneId);

        // Only consider it drift if:
        // - Y.js HAS a timestamp AND DB timestamp is newer
        // - Don't count missing Y.js timestamps as drift (could be initialization lag)
        if (yjsTimestamp && dbTimestamp > yjsTimestamp) {
          driftedScenes.push(sceneId);
          if (dev)
            console.log(
              `[${this.clientId}] Drift detected for scene ${sceneId}: DB=${new Date(dbTimestamp).toISOString()}, Y.js=${new Date(yjsTimestamp).toISOString()}`
            );
        }
      }

      // Log summary for debugging
      const totalScenesWithTimestamps = Object.keys(dbTimestamps).length;
      if (dev) {
        if (totalScenesWithTimestamps > 0) {
          console.log(
            `[${this.clientId}] Drift check complete: ${driftedScenes.length} drifted out of ${totalScenesWithTimestamps} scenes with DB timestamps`
          );
        } else {
          console.log(`[${this.clientId}] Drift check complete: No scenes have timestamps yet (migration period)`);
        }
      }

      return driftedScenes;
    } catch (error) {
      console.error(`[${this.clientId}] Error detecting drift:`, error);
      return [];
    }
  }

  /**
   * Get the raw Socket.IO connection from the party provider
   * This is used for cursor tracking and other non-Y.js real-time features
   */
  getSocket() {
    return this.partyProvider.socket;
  }

  /**
   * Check if socket is connected
   */
  isSocketConnected() {
    return this.partyProvider.socket && this.partyProvider.socket.connected;
  }

  /**
   * Register a cursor event handler
   * @param event The event name (e.g., 'cursorMove', 'cursorUpdate')
   * @param handler The handler function
   */
  onCursorEvent(event: string, handler: (data: any) => void) {
    if (!this.cursorHandlers.has(event)) {
      // Register the event on the socket only once
      this.partyProvider.socket.on(event, (data: any) => {
        const handlers = this.cursorHandlers.get(event);
        if (handlers) {
          handlers(data);
        }
      });
    }
    this.cursorHandlers.set(event, handler);
  }

  /**
   * Remove a cursor event handler
   * @param event The event name
   */
  offCursorEvent(event: string) {
    if (this.cursorHandlers.has(event)) {
      this.cursorHandlers.delete(event);
      this.partyProvider.socket.off(event);
    }
  }

  /**
   * Emit a cursor event
   * @param event The event name
   * @param data The data to emit
   */
  emitCursorEvent(event: string, data: any) {
    // The socket is already connected to the correct namespace/room via Y.js
    this.partyProvider.socket.emit(event, data);
  }

  /**
   * Clean up resources
   */
  destroy() {
    if (dev) console.log(`[${this.clientId}] Destroying PartyDataManager for user ${this.userId}`);

    // Clean up cursor handlers
    for (const event of this.cursorHandlers.keys()) {
      this.partyProvider.socket.off(event);
    }
    this.cursorHandlers.clear();

    if (this.provider) {
      this.provider.destroy();
    }
    if (this.partyProvider) {
      this.partyProvider.destroy();
    }
    if (this.doc) {
      this.doc.destroy();
    }
    if (this.partyDoc) {
      this.partyDoc.destroy();
    }
    this.subscribers.clear();
    this.sceneObservers.clear();
  }
}
